-----------------------------------------------------------------------
| CERTIFICATES AND PUBLIC KEY INFRASTRUCTURE                          |
-----------------------------------------------------------------------

- Basics

    - Entity and Identity

        - An 'entity' is anything that exists (ie a computer or a burrito).

        - Every entity has an 'identity'.  On computers, identity is usually represented as a bag
            of attributes.

        - An 'identifier' is a unique reference to some entity that has an identity.

        - An entity can also have a 'name', which is different from an identifier.  For our purpose, we
            can think of identifiers and names as synonyms.


    - Authentication

        - Entities can claim they have some particular name.  Other entities might be able to authenticate
            that claim, confirming it's truth.

        - 'Authentication' is the process of confirming the truth of some claim.


    - Certificates

        - A 'subscriber' (or 'end entity') is an entity that is participating in a PKI and can be the
            'subject' of a certificate.

        - A 'CA' is an entity that issues certificates to subscribers.  It is a certificate issuer.

        - Certificates that belong to subscribers are sometimes called 'entity certificates' (or 'leaf
            certificates').

        - Certificates that belong to CAs are usually called 'root certificates' (or 'intermediate
            certificates').

        - A 'relying party' is a certificate user that verifies and trusts certificates issued by a CA.

        - An entity can be both a subscriber and relying party.  That is, a single entity can both have
            it's own certificate and use other certificates to authenticate remote peers (ie with mutual
            TLS).



- MACs and Signatures Authenticate Stuff

    - MACs and Hash Functions
    
        - A MAC (Message Authentication Code) is a bit of data that is used to verify which entity sent
            a message, and ensure the message hasn't been modified.

        - The basic idea is to feed a shared secret (a password) along with a message through a hash 
            function.  The hash output is a MAC.  You send the MAC along with the message to some
            recipient.

        - A recipient that also knows the shared secret can produce their own MAC and compare it to the
            one provided.  If the recipient's MAC matches the one sent with the message, it can be
            confident the message was sent by another entity that knows the shared secret.  Assuming only
            trusted entities know the shared secret, the recipient can trust the message.

        - Hash functions are one-way functions, so it is computationally infeasible to reconstruct the 
            input from the output.  Whether this property holds depends on subtle details of how hash
            functions work, so don't try to write your own.  Just use the HMAC algorithm.


    - Signatures

        - A 'signature' is conceptually similar to a MAC, but instead of using a shared secret you use a
            key pair.

        - With a MAC, the sender and the recipient both need to know the shared secret.  A valid MAC
            could have been generated by either party, and you can't tell which.

        - Signatures are different.  A signature can be verified using a public key, but can only be
            generated with a corresponding private key.  Thus, a recipient that only has a public key
            can verify signatures, but can't generate them.

        - This gives you tighter control over who can sign stuff.  If only one entity knows a private
            key, you get a property called 'non-repudiation'.  The private key holder can't deny that
            they signed some data.



- Public Key Cryptography

    - Key Pairs

        - Certificates and PKI are built on 'public key cryptography' (aka 'asymmetric cryptography'),
            which uses key pairs.

        - A key pair consists of a 'public key' that can be distributed and shared with the world, as well
            as a 'private key' that should be kept confidential by the owner.

        - The security of a cryptosystem depends on keeping the private key private.


        - There are 2 things you can do with a key pair:

            1. You can 'encrpyt' some data with the public key.  The only way to decrypt that data is 
                 with the corresponding private key.

            2. You can 'sign' some data using the private key.  Anyone who knows the corresponding 
                 public key can verify the signature, proving which private key produced it.


    - Public Key Cryptography

        - Public key cryptography is a magical gift from mathematics to computer science.  It allows
            one computer to prove to another that it knows something without sharing the knowledge
            directly.

        - To prove you know a password, you have to share it.  Not so with a private key.  It's like
            vision.  If you know what I look like, you can tell who I am - authenticate my identity -
            by looking at me.  But, you can't shape-shift to impersonate me.

        - Public key cryptography does something similar.  If you know my public key (what I look like),
            you can use it to see me across the network.  For example, you can send me a big random
            number.  I can sign your number and send you my signature.  Verifying that signature is
            good evidence you're talking to me.  This effectively allows computers to see who they're
            talking to across a network.



- Certificates

    - Certificates

        - What if you don't already know my public key?  That's what certificates are for.  A 'certificate'
            is a data structure that contains a public key and a name.  The data structure is then
            'signed'.   The signature 'binds' the public key to the name.


        - The entity that signs a certificate is called the 'issuer' (or CA) and the entity named in the
            certificate is the 'subject'.

            [Certificate]
            Name: Bob
            PublicKey: 01:23:42
            Signed: Some Issuer


        - If Some Issuer signs a certificate for Bob, the issuer is claiming that the public key belongs
            to Bob.  The claim is signed by Some Issuer, so if you know Some Issuer's public key, you
            can authenticate it by verifying the signature.  If you trust Some Issuer, you can trust the
            claim.

        - Thus, certificates let you use trust, and knowledge of an issuer's public key, to learn another
            entity's public key.


    - X.509 v3 Certificates

        - Encoding
        
            - The structure forseen by the standards are expressed in a formal language called ASN.1 
                (Abstract Syntax Notation).

            - The X.690 standard defines ASN.1 encoding formats.  BER (Basic Encoding Rules) just
                defines binary octets.  CER (Canonical Encoding Rules) and DER (Distinguished Encoding
                Rules) are restricted forms of BER.

            - DER is a subset of BER that provides for exactly one way to encode an ASN.1 value.  It
                is intended for when a unique encoding is needed, such as cryptography.


        - Structure of a Certificate

            > Certificate
              > Version number
              > Serial number
              > Signature algorithm id
              > Issuer name
              > Validity Period
                > Not Before
                > Not After
              > Subject Name
              > Subject Public Key Info
                > Public Key Algorithm
                > Public Key

              > Issuer Unique Identifier (optional)
              > Subject Unique Identifier (optional)
              > Extensions (optional)

            > Certificate signature algorithm
            > Certificate signature



- X.509, ASN.1, OIDs, DER, PEM, PKCS

    - X.509

        - Usually when people talk about certificates without additional qualifications, they're talking
            about X.509 v3 certificates.  These are the types of certificates browsers understand and
            use for HTTPS (HTTP over TLS).

        - These certificates are the most frequently used in other contexts like internal PKI as well.
            They work out of the box with TLS and HTTPS clients and servers.

        - X.509 was first standardized in 1988 as part of the X.500 project of the ITU-T.  X.500 was an
            effort by the telcos to build a global phone book, which never actually happened.  This is
            why X.509 certificates have a locality, state, and country.


    - ASN.1 

        - X.509 builds on ASN.1, another ITU-T standard.  It is a notation for defining data types.
            You can think of it like JSON, but it is actully more like protobuf or thrift.

        - RFC 5280 uses ASN.1 to define a X.509 certificate as an object that contains various bits of
            information like a name, key, signature, etc.

        - ASN.1 has normal data types like integers, strings, sets, and sequences.  It also has an
            unusual type called OIDs (object identifiers).  They're similar to a URI that is supposed to
            be unique.  You can use an ORI to tag a bit of data with a type.  A string is just a string,
            but if I tag a string with OID '2.5.4.3', it's no longer an ordinary string - it's an X.509
            common name.


        - Tools like openssl pretty-print ASN.1 like this:

            Subject: C=US,ST=CA,L=San Francisco,O=Slack Technologies, Inc.,CN=slack.com


    - Encoding Rules

        - ASN.1 is abstract in that the standard doesn't say anything about how stuff should be
            represented as bits and bytes.  For that, there are various encoding rules that specify
            concrete representations for ASN.1 data values.

        - There are a bunch of encoding rules for ASN.1, but the only one commonly used for X.509
            certificates and other crypto stuff is DER.  DER is a simple type-length-value encoding.


        - Unfortunately, the story doesn't stop there.  You will need to figure out whether a
            particular certificate is a plain DER-encoded X.509 certificate or something fancier.
            There are 2 potential dimensions of fanciness:

            1. We might be looking at something more than raw DER
            2. We might be looking at something more than a certificate


    - #1 - Something more than a raw DER

        - DER is straight binary, which is hard to copy-paste and send around the web.  So,
            most certificates are packaged up in PEM files ('Privacy Enhanced Email').  Similar to MIME,
            PEM is a base64-encoded payload sandwiched between a header and a footer.  This is what a
            PEM-encoded X.509 v3 certificate looks like:

            -----BEGIN CERTIFICATE-----
            MIIBwzCCAWqgAwIBAgIRAIi5QRl9kz1wb+SUP20gB1kwCgYIKoZIzj0EAwIwGzEZ
            MBcGA1UEAxMQTDVkIFRlc3QgUm9vdCBDQTAeFw0xODExMDYyMjA0MDNaFw0yODEx
            MDMyMjA0MDNaMCMxITAfBgNVBAMTGEw1ZCBUZXN0IEludGVybWVkaWF0ZSBDQTBZ
            MBMGByqGSM49AgEGCCqGSM49AwEHA0IABAST8h+JftPkPocZyuZ5CVuPUk3vUtgo
            cgRbkYk7Ong7ey/fM5fJdRNdeW6SouV5h3nF9JvYKEXuoymSNjGbKomjgYYwgYMw
            DgYDVR0PAQH/BAQDAgGmMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAS
            BgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQWBBRc+LHppFk8sflIpm/XKpbNMwx3
            SDAfBgNVHSMEGDAWgBTirEpzC7/gexnnz7ozjWKd71lz5DAKBggqhkjOPQQDAgNH
            ADBEAiAejDEfua7dud78lxWe9eYxYcM93mlUMFIzbWlOJzg+rgIgcdtU9wIKmn5q
            FU3iOiRP5VyLNmrsQD3/ItjUN1f1ouY=
            -----END CERTIFICATE-----


        - PEM-encoded certificates will usually carry a '.pem', '.crt', or '.cer' extension.  A raw
            certificate encoded using DER will usually carry a '.der' extension.


    - #2 - Something more than a certificate

        - In addition to fancier encoding using PEM, a certificate might be wrapped up in
            fancier packaging.  Several 'envelope formats' define larger data structures (still using 
            ASN.1) that contain certificates, keys, and other stuff.  Some things ask for certificates,
            when what they really want are certificates wrapped up in one of these envelopes.

        - The envelope standards you're likely to encounter are part of a suite of standards called PKCS
            (Public Key Cryptography Standards) published by RSA labs.

        - The first standard is PKCS#7 (aka 'Cryptographic Message Syntax'), which can contain one or 
            more certificates (encoding a full certificate chain).  PKCS#7 is commonly used by Java.
            Common extensions are '.p7b' and '.p7c'.

        - The other common envelope format is PKCS#12, which can contain both a certificate chain and an
            encrypted private key.  PKCS#12 is commonly used by Microsoft products.  Common extensions
            are '.pfx' and '.p12'.


    - Other Files Types

        - Deciphering the sort of key you're looking at is half science, half art.


        - Elliptic curve keys are usually labeled as such.  Other keys are simply "PRIVATE KEY" by PEM. 
            This usually indicates a PKCS#8 payload, an envelope for private keys that includes key type 
            and other metadata. Here's an example of a PEM-encoded elliptic curve key:

            $ cat ec.pub ec.prv

            -----BEGIN PUBLIC KEY-----
            MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEc73/+JOESKlqWlhf0UzcRjEe7inF
            uu2z1DWxr+2YRLfTaJOm9huerJCh71z5lugg+QVLZBedKGEff5jgTssXHg==
            -----END PUBLIC KEY-----
            -----BEGIN EC PRIVATE KEY-----
            MHcCAQEEICjpa3i7ICHSIqZPZfkJpcRim/EAmUtMFGJg6QjkMqDMoAoGCCqGSM49
            AwEHoUQDQgAEc73/+JOESKlqWlhf0UzcRjEe7inFuu2z1DWxr+2YRLfTaJOm9hue
            rJCh71z5lugg+QVLZBedKGEff5jgTssXHg==
            -----END EC PRIVATE KEY-----


        - It is also quite common to see private keys encrypted using a password.  Those will look
            something like this:

            -----BEGIN EC PRIVATE KEY-----
            Proc-Type: 4,ENCRYPTED
            DEK-Info: AES-256-CBC,b3fd6578bf18d12a76c98bda947c4ac9

            qdV5u+wrywkbO0Ai8VUuwZO1cqhwsNaDQwTiYUwohvot7Vw851rW/43poPhH07So
            sdLFVCKPd9v6F9n2dkdWCeeFlI4hfx+EwzXLuaRWg6aoYOj7ucJdkofyRyd4pEt+
            Mj60xqLkaRtphh9HWKgaHsdBki68LQbObLOz4c6SyxI=
            -----END EC PRIVATE KEY-----


        - PKCS#8 objects can also be encrypted, in which case the header label should be "ENCRYPTED
            PRIVATE KEY".

        - Public keys will usually have a '.pub' or '.pem' extension.  Private keys may carry a '.prv',
            '.key', or '.pem' extension.  However, your mileage may vary.



- Public Key Infrastructure

    - 'PKI' is the umbrella term for all the stuff we need in order to issue, distribute, store, use, 
        verify, revoke, and otherwise manage and interact with certificates and keys.

    - Certificates are the building blocks of most PKIs, and CAs are the foundations.  PKI also includes 
        libraries, protocols, conventions, clients, servers, names, discovery mechanisms, and all the
        other stuff you need to use public key cryptography effectively.

    - Many simple PKIs don't even use certificates.  For instance, when you edit '~/.ssh/authorized_keys',
        you're configuring a simple certificate-less form of PKI that SSH uses to bind public keys to
        names in flat files.

    - Remember that the simple goal of certificates is to bind names to public keys.



- Web PKI vs Internal PKI

    - You interact with Web PKI via your browser whenever you access an HTTPS URL.  Despite it's
        problems, it substantially improves security on the web and is mostly transparent to users.
        You should use it everywhere your system communicates with the outside world over the internet.


    - Web PKI is mostly defined by RFC 5280.  For example, it defines: 

        - The type of certificates used
        - What a "name" is and where it goes in a certificate
        - What signature algorithms can be used
        - How a relying party determines the issuer of a certificate
        - How a certificate's validity period is specified
        - How revocation and certificate path validation works
        - The process that CAs use to determine whether someone owns a domain


    - Web PKI is important, because Web PKI certificates work by default with browsers and pretty much
        everything else that uses TLS.


    - Internal PKI is PKI you run yourself, for your own stuff:

        - Production infrastructure like services, contains, and VMs
        - Enterprise IT applications
        - Corporate endpoints like laptops and phones
        - Any other code you want to identify


    - Internal PKI allows you to authenticate and establish cryptographic channels so your stuff can
        run anywhere and securely communicate, even across the public internet.


    - Why should you run your own Internal PKI if Web PKI already exists?  The answer is because Web PKI
        wasn't designed to support internal use cases.  

        - Even with a CA like Let's Encrypt, which offers free certificates and automated provisioning, 
            you'll have to deal with rate limits and availability.  That's no good if you have lots of 
            services to deploy all the time.

        - With Web PKI, you have little control over details like certificate lifetime, revocation
            mechanisms, renewal processes, key types, and algorithms.

        - The CA/Browser Forum Baseline Requirements prohibit Web PKI CAs from binding internal IPs
            (ie 10.0.0.0/8) or internal DNS names that aren't fully-qualified and resolvable in public
            global DNS.  For instance, you can't bind a K8s cluster DNS name like 'foo.ns.svc.cluster.local'.
            To do this, you'll need your own internal PKI.


    - In conclusion, use Web PKI for your public website and APIs.  Use your own internal PKI for 
        everything else.
